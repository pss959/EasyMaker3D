# -----------------------------------------------------------------------------
# Building the release as a Zip file.
# -----------------------------------------------------------------------------

from re         import compile, match
from subprocess import Popen, PIPE, run
from os         import walk
from os.path    import basename, dirname, isfile, join, relpath
from zipfile    import ZipFile

Import('rel_dict')

# -----------------------------------------------------------------------------
# General helper functions.
# -----------------------------------------------------------------------------

# Creates the release Zip file. NOTE: The 'Zip()' builder in SCons claims to
# allow the command to be modified with the 'ZIP', 'ZIPFLAGS', and other
# construction variables. However, they are actually not used in the
# SCons.Tool.zip source file. So do everything manually here.
def BuildZipFile_(target, source, env):
    zf = ZipFile(str(target[0]), 'w')
    def AddFile_(f, rel_path):
        zf.write(f, f'{rel_dict["app_name"]}/{rel_path}')
    for src in source:
        name = str(src)
        # Walk through directories.
        if src.isdir():
            basedir = dirname(name)
            for root, dirs, files in walk(name):
                for f in files:
                    path = join(root, f)
                    if isfile(path):
                        AddFile_(path, relpath(path, basedir))
        else:  # Regular file - add at the top level.
            AddFile_(name, basename(name))

# -----------------------------------------------------------------------------
# Mac-specific helper functions. Need to copy all dependent libraries into the
# Zip file and change all relative paths to use @rpath.
# -----------------------------------------------------------------------------

# Recursively collects dependency libraries for the given target, adding to
# both replacement_dict and source_dict.
def CollectMacLibs_(target, replacement_dict, source_dict):
    # Stop if already handled.
    if target in replacement_dict:
        return

    # replacement_dict maps the target (as is) to the base file name.
    name      = basename(target)
    replacement_dict[target] = name

    # source_dict maps the name to a valid absolute path to the target. (There
    # may be multiple locations; any one is ok.)
    full_path = File(target).abspath
    source_dict[name] = full_path

    # Handle dependencies: get the results of running "otool -L" on the target.
    lines = Popen(['otool', '-L', full_path],
                  stdout=PIPE, text=True).stdout.read().splitlines()
    prog = compile(r'.*/([^/]+\.dylib)')
    # Skip the first line, which is the name of the target.
    for line in lines[1:]:
        line = line.strip()
        # Skip lines starting with '@', '/System/', or '/usr/lib'; they are ok.
        if (line.startswith('@') or
            line.startswith('/System') or
            line.startswith('/usr/lib')):
            continue
        # Extract the library name and recurse on it.
        result = prog.match(line)
        if result:
            CollectMacLibs_(result.group(), replacement_dict, source_dict)

# For the given target application and each dependent library, this creates a
# copy in a temporary directory and processes it to change the load path to be
# relative to @rpath.  This returns a list of paths to add to the Zip file.
def FixMacFiles_(env, app):
    # Collect which files to process.
    replacement_dict = {}
    source_dict      = {}
    CollectMacLibs_(str(app), replacement_dict, source_dict)

    # Use the replacement_dict to construct most of a command to replace all
    # library paths in the dictionary with rpath-relative ones.
    replace_cmd = 'install_name_tool '
    for path, name in replacement_dict.items():
        replace_cmd += f'-change {path} {join("@rpath", name)} '

    # Use the source_dict to create a processed copy of each source.
    targets = []
    tmp_dir = '$BUILD_DIR/TMP'
    for name, source_path in source_dict.items():
        target = join(tmp_dir, name)
        env.Command(target, source_path,
                    ['echo Building $TARGET from $SOURCE',
                     Mkdir(tmp_dir),
                     Copy('$TARGET', '$SOURCE', False),  # Copy links as files.
                     f'{replace_cmd} -id {name} $TARGET'])
        targets.append(target)
    return targets

# -----------------------------------------------------------------------------
# Building the release.
# -----------------------------------------------------------------------------

app_env = rel_dict['app_env']

# Zip the files to include in the release.
zip_input  = [rel_dict['app'], rel_dict['app_lib'], rel_dict['ion_lib'],
              rel_dict['ovr_lib'], rel_dict['res_dir']]
zip_output = f'$BUILD_DIR/Release/{rel_dict["rel_name"]}.zip'

# Windows requires all dependent libraries to be present.
zip_win_mingw_libs = [
    'glfw3',
    'libbrotlicommon',
    'libbrotlidec',
    'libbz2-1',
    'libfreetype-6',
    'libgcc_s_seh-1',
    'libglib-2.0-0',
    'libgmp-10',
    'libgraphite2',
    'libharfbuzz-0',
    'libiconv-2',
    'libintl-8',
    'libmpfr-6',
    'libpcre2-8-0',
    'libpng16-16',
    'libstdc++-6',
    'libwinpthread-1',
    'zlib1',
]
if app_env['PLATFORM'] == 'mac':
    # Have to replace a few items, so rebuild the input list.
    zip_input = (FixMacFiles_(app_env, rel_dict['app']) +
                 [rel_dict['ovr_lib'], rel_dict['res_dir']])
elif app_env['PLATFORM'] == 'windows':
    mingw_dir = app_env.ConvertPath('/mingw64/bin')
    zip_input += [f'{mingw_dir}/{lib}.dll' for lib in zip_win_mingw_libs]

rel = app_env.Command(zip_output, zip_input, BuildZipFile_)
Return('rel')
