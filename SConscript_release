from re         import compile, match
from shutil     import copyfile, copytree, ignore_patterns
from subprocess import Popen, PIPE, run
from os         import makedirs, rmdir, walk
from os.path    import basename, dirname, isdir, isfile, join, relpath
from zipfile    import ZipFile

Import('rel_dict')

# -----------------------------------------------------------------------------
# Linux/Windows helper functions. Builds a Zip file containing the app and all
# other necessary files.
# -----------------------------------------------------------------------------

# Creates the release Zip file. NOTE: The 'Zip()' builder in SCons claims to
# allow the command to be modified with the 'ZIP', 'ZIPFLAGS', and other
# construction variables. However, they are actually not used in the
# SCons.Tool.zip source file. So do everything manually here.
def BuildZipFile_(target, source, env):
    exclusions = env['RESOURCE_EXCLUSIONS']
    zf = ZipFile(str(target[0]), 'w')
    def AddFile_(f, rel_path):
        if not f in exclusions:
            zf.write(f, f'{rel_dict["app_name"]}/{rel_path}')
    for src in source:
        name = str(src)
        # Walk through directories.
        if src.isdir():
            basedir = dirname(name)
            for root, dirs, files in walk(name):
                if not root in exclusions:
                    for f in files:
                        path = join(root, f)
                        if isfile(path):
                            AddFile_(path, relpath(path, basedir))
        else:  # Regular file - add at the top level.
            AddFile_(name, basename(name))

def BuildReleaseZipFile_(env):
    zip_input  = [rel_dict['app'], rel_dict['app_lib'], rel_dict['ion_lib'],
                  rel_dict['ovr_lib'], rel_dict['res_dir']]
    zip_output = f'$BUILD_DIR/Release/{rel_dict["rel_name"]}.zip'
    if env['PLATFORM'] == 'windows':
        # Windows requires all dependent libraries to be present.
        zip_win_mingw_libs = [
            'glfw3',
            'libbrotlicommon',
            'libbrotlidec',
            'libbz2-1',
            'libfreetype-6',
            'libgcc_s_seh-1',
            'libglib-2.0-0',
            'libgmp-10',
            'libgraphite2',
            'libharfbuzz-0',
            'libiconv-2',
            'libintl-8',
            'libmpfr-6',
            'libpcre2-8-0',
            'libpng16-16',
            'libstdc++-6',
            'libwinpthread-1',
            'zlib1',
        ]
        mingw_dir = env.ConvertPath('/mingw64/bin')
        zip_input += [f'{mingw_dir}/{lib}.dll' for lib in zip_win_mingw_libs]
    return env.Command(zip_output, zip_input, BuildZipFile_)

# -----------------------------------------------------------------------------
# Mac-specific helper functions. Builds a DMG from a bundle.
#
# Bundle hierarchy, created under $BUILD_DIR :
#  {app_name}.app/Contents/
#        Frameworks/
#           <all dylibs>
#        Info.plist [generated here]
#        MacOS/
#           <app>
#        Resources/
#           resources/...
#
# 'install_name_tool' is used to fix paths in the app and dylibs, as follows:
#    app refers to each dylib as:
#           '@loader_path/../Frameworks/<full-dylib-name.dylib>'
#    each dylib has ID:
#           '@executable_path/../Frameworks/<full-dylib-name.dylib>'
#       and refers to other dylibs as:
#           '@loader_path/../Frameworks/<full-dylib-name.dylib>'
# -----------------------------------------------------------------------------

# -----------------------------------------------------------------------------
# This class does most of the work for building a Mac release.
# -----------------------------------------------------------------------------

class MacHelper(object):
    def BuildDMG(self, env, target, app):
        # Step 1: Collect libraries to fill dictionaries:
        #  _lib_replacement_dict maps full path => library file name.
        #  _lib_source_dict maps library file name => absolute path to library.
        self._lib_source_dict      = {}
        self._lib_replacement_dict = {}
        self._CollectLibs(app)

        # Step 2: Copy everything into a bundle directory.
        app_name = rel_dict['app_name']
        bundle_path = env.Dir(f'$BUILD_DIR/{app_name}.app').abspath
        (bundled_app, bundled_libs) = self._CreateBundle(env, app, bundle_path)

        # Step 3: Fix all of the library paths in the bundled app and libs.
        self._FixLibs(env, bundled_app, bundled_libs)

        # Step 4: Create a DMG from the bundle directory.
        dmg_file = File(target[0]).abspath
        dmg_cmd = f'tar cfz {dmg_file} {bundle_path}'
        run(Split(dmg_cmd))

    # -------------------------------------------------------------------------

    # Recursively collects dependency libraries for the given target (app
    # or library).
    def _CollectLibs(self, target):
        for lib_path in self._GetLibPaths_(target):
            if lib_path in self._lib_replacement_dict:  # Already handled
                continue

            name      = basename(lib_path)
            full_path = File(lib_path).abspath

            self._lib_replacement_dict[lib_path] = name
            self._lib_source_dict[name]          = full_path

            # Recurse.
            self._CollectLibs(lib_path)

    # Runs otool on the given target (app or library) and returns a list of paths
    # of dependent libraries.
    def _GetLibPaths_(self, target):
        prog = compile(r'.*/([^/]+\.dylib)')

        # Get dependent library lines.
        full_path = File(target).abspath
        lines = Popen(['otool', '-L', full_path],
                      stdout=PIPE, text=True).stdout.read().splitlines()

        # Skip the first line, which is the name of the target.
        return [lib_path for line in lines[1:]
                if (lib_path := self._GetLibLine(prog, line))]

    def _GetLibLine(self, prog, line):
        line = line.strip()
        # Skip lines starting with '@', '/System/', or '/usr/lib'; they are ok.
        if (line.startswith('@') or
            line.startswith('/System') or
            line.startswith('/usr/lib')):
            return ''
        # See if there is a parsable library.
        result = prog.match(line)
        return result.group() if result else ''

    def _CreateBundle(self, env, app, bundle_path):
        app_name = basename(str(app))

        if isdir(bundle_path):
            rmdir(bundle_path)
        makedirs(f'{bundle_path}/MacOS/')
        makedirs(f'{bundle_path}/Frameworks/')
        makedirs(f'{bundle_path}/Resources/')

        # Copy the app.
        bundled_app = f'{bundle_path}/MacOS/{app_name}'
        copyfile(File(app).abspath, bundled_app)

        # Copy the libraries.
        bundled_libs = []
        for lib_name, lib_path in self._lib_source_dict.items():
            bundled_lib = f'{bundle_path}/Frameworks/{lib_name}'
            copyfile(lib_path, bundled_lib)
            bundled_libs.append(bundled_lib)

        # Copy the resources directory.
        print(f'XXXX Copying resources')
        exclusions = env['RESOURCE_EXCLUSIONS']
        def Exclude_(directory, contents):
            return ([directory] if directory in exclusions else
                    [c for c in contents if c in exclusions])
        copytree('resources', f'{bundle_path}/Resources/resources',
                 ignore=Exclude_)

        # The app and libs need to be fixed.
        return (bundled_app, bundled_libs)

    def _FixLibs(self, env, app, libs):
        # Construct most of a command to replace library paths with
        # bundle-relative ones.
        replace_cmd = 'install_name_tool '
        for old_path, name in self._lib_replacement_dict.items():
            new_path     = f'@loader_path/../Frameworks/{name}'
            replace_cmd += f'-change {old_path} {new_path} '

        # Fix the app.
        run(Split(f'{replace_cmd} {app}'))

        # Fix the libraries.
        for lib in libs:
            lib_name = basename(lib)
            lib_id = f'@executable_path/../Frameworks/{lib_name}'
            run(Split(f'{replace_cmd} -id {lib_id} {lib}'))

# -----------------------------------------------------------------------------

# This is used to build a DMG on the Mac. This uses a Builder because it has
# to execute after the application and its dependency libraries are built.
def BuildMacDMG_(env):
    # SCons Builder that creates the DMG for the release. The source is a list
    # whose first element is the app. The target is the DMG file path.
    def MacDMGBuilder_(target, source, env):
        MacHelper().BuildDMG(env, target, source[0])
        return None  # Success!

    env.Append(BUILDERS={ 'BuildMacDMG' : Builder(action=MacDMGBuilder_) })

    app_name = rel_dict['app_name']
    dmg_file = f'$BUILD_DIR/Release/{app_name}.dmg'
    sources  = [rel_dict['app'], rel_dict['app_lib'], rel_dict['ion_lib']]
    env.BuildMacDMG(target=dmg_file, source=sources)
    return dmg_file

# -----------------------------------------------------------------------------
# Building the release. The release is a Zip file on Linux and Windows and a
# DMG on Mac.
# -----------------------------------------------------------------------------

app_env = rel_dict['app_env']

rel = (BuildMacDMG_(app_env) if app_env['PLATFORM'] == 'mac'
       else BuildReleaseZipFile_(app_env))

Return('rel')
