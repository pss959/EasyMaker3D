- Need to fix aspect ratio: stretching window should not scale nonuniformly.

- Figure out why view is different

- Figure out Widget stuff (including read/write).

====================

- Figure out how to tell if any field was read
  - Wrap in Field class that stores a flag?
  - This could also be used to write out fields generically.

  TField<T> stores value + name + flag.

  Constructor for any derived Parser::Object adds its TFields to a vector in
  the base Object class.
    - Parser reads a field name, looks in this vector, and calls appropriate
       ReadValue<T> for it.
    - Handle all Math types that appear in fields.

  Writer can do exactly the same thing, but in reverse.

  So:   Material : Object
      Registers type with Parser: passes creation_func.
      Parser creates new Object using creation_func, then calls AddFields()

      E.g.,
         Material
           private:
              TField<Vector4f> base_color_;
              TField<float>    smoothness_;
              TField<float>    metalness_;

        virtual void Material::AddFields() override {
            AddField(base_color_);
            AddField(smoothness_);
            AddField(metalness_);
        }
