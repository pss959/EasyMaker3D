# -----------------------------------------------------------------------------
# Generates public documentation using Sphinx in the "PublicDoc/site"
# subdirectory of the build directory.
# -----------------------------------------------------------------------------

from os      import environ, makedirs, walk
from os.path import dirname, join, relpath

Import('app_dict', 'doc_build_dir', 'snapimage')

# -----------------------------------------------------------------------------
# Helper functions.
# -----------------------------------------------------------------------------

# Recursive function to find all files under a root directory.
def FindAllSources_(root_dir):
    sources = []
    for root, dirnames, filenames in walk(root_dir, topdown=True):
        # Skip directories beginning with '.'.
        [dirnames.remove(d) for d in list(dirnames) if d.startswith('.')]
        sources += [join(root, fn) for fn in filenames]
    return sources

# -----------------------------------------------------------------------------
# Environment.
# -----------------------------------------------------------------------------

env = Environment(
    OUTPUT_DIR     = f'#{doc_build_dir}/PublicDoc',
    VERSION_SUBDIR = app_dict['VERSION_STRING'],
    VERSION_DIR    = '$OUTPUT_DIR/$VERSION_SUBDIR',

    # Copy the environment variables for the snapimage application.
    ENV = environ.copy(),
)

# Pass values through to Sphinx via environment variables.
env.Append(
    ENV = {
        'PROJECT'   : app_dict['APP_NAME'],
        'VERSION'   : app_dict['VERSION_STRING'],
        'SUFFIX'    : app_dict['SESSION_SUFFIX'],
        'COPYRIGHT' : app_dict['COPYRIGHT'],
        'BASE_URL'  : app_dict['PUBLIC_DOC_BASE_URL'],
    },
)

# Builder function that creates an HTML URL redirect file. source is the
# absolute path to the file to redirect to; target is the absolute path to the
# file to redirect from.
def AddRedirect_(target, source, env):
    abs_from_path = str(target[0])
    abs_to_path   = str(source[0])
    rel_to_path   = relpath(abs_to_path, start=dirname(abs_from_path))
    makedirs(dirname(abs_from_path), exist_ok=True)
    with open(abs_from_path, 'w') as f:
        f.write(f"""<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="Refresh" content="0; url='{rel_to_path}'" />
  </head>
  <body>
  </body>
</html>
""")
    return None  # Success!

env.Append(BUILDERS={ 'AddRedirect' : Builder(action=AddRedirect_) })

# -----------------------------------------------------------------------------
# Global variables.
# -----------------------------------------------------------------------------

output_doc_path  = env.Dir('$VERSION_DIR').abspath

# -----------------------------------------------------------------------------
# Cheat Sheet generation. This goes in the 'PublicDoc/docs' directory so it can
# be processed like all the other input.
# -----------------------------------------------------------------------------

cs_output    = 'docs/CheatSheet.rst'
cs_generator = '#build/opt/Apps/createcheatsheet'
env.Command(cs_output, cs_generator, '$SOURCE > $TARGET')

# -----------------------------------------------------------------------------
# Snapshot Image generation and annotation.
# -----------------------------------------------------------------------------

root_dir   = env.Dir('#').abspath   # Work around SCons issue.
image_dir  = './docs/images'
script_dir = './snaps/scripts'
ann_dir    = './snaps/annotations'
annotator  = env.File('#/bin/annotate.py').abspath

# This maps snapimage script files to the images they generate.
snap_map = {
  'AppPanels1' : [
    'ActionPanel',
    'DialogMessagePanel',
    'DialogQuestionPanel',
    'HelpPanel',
    'InfoPanel',
    'RadialMenuPanel',
    'SettingsPanel',
  ],
  'AppPanels2' : [
    'FilePanel',
    'GripPanelBar',
    'VirtualKeyboardPanel',
  ],
  'CSG' : [
    'CSGDifference',
    'CSGIntersection',
    'CSGOperands',
    'CSGUnion',
  ],
  'Controller' : [
    'OculusTouch',
    'TouchMode',
    'Vive',
  ],
  'Doorstop' : [
    'Doorstop',
  ],
  'Feedback' : [
    'AngularFeedback',
    'LinearFeedback',
  ],
  'GeneralTools' : [
    'ColorTool',
    'ComplexityToolHigh',
    'ComplexityToolLow',
    'NameTool',
    'RotationTool',
    'RotationToolVRSphere',
    'RotationToolVRX',
    'RotationToolVRZ',
    'ScaleTool',
    'ScaleToolVRUniform',
    'ScaleToolVRX',
    'TranslationTool',
    'TranslationToolVRX',
    'TranslationToolVRZ',
  ],
  'Hull' : [
    'HullCapsule',
    'HullDisk',
    'HullSpheres',
    'HullTorus',
  ],
  'InvalidColors' : [
    'InvalidColors',
  ],
  'LinearLayout' : [
    'LinearLayout',
  ],
  'Main' : [
    'BuildVolume',
    'Logo',
    'PrecisionControl',
    'WorkArea',
    'WorkAreaWithSelection',
  ],
  'ModelEdges' : [
    'ModelEdges',
    'ModelNoEdges',
  ],
  'Primitives' : [
    'PrimitiveBox',
    'PrimitiveCylinder',
    'PrimitiveImported',
    'PrimitiveRevSurf',
    'PrimitiveSphere',
    'PrimitiveText',
    'PrimitiveTorus',
  ],
  'Quickstart' : [
    'QuickstartCylinder',
    'QuickstartExport',
    'QuickstartHull',
    'QuickstartRenamed',
    'QuickstartScale',
    'QuickstartSelected',
    'QuickstartTorus',
    'SessionPanel',
  ],
  'RadialLayout' : [
    'RadialLayoutArc',
    'RadialLayoutMultiple',
    'RadialLayoutRadius',
    'RadialLayoutSingle',
  ],
  'RadialMenu' : [
    'AttachedRadialMenu',
    'FixedRadialMenu',
  ],
  'Selection' : [
    'Selection',
  ],
  'Shelves' : [
    'BasicsShelf',
    'BevelToolIcon',
    'CSGToolIcon',
    'ClipToolIcon',
    'CylinderToolIcon',
    'GeneralToolShelf',
    'ImportToolIcon',
    'LayoutShelf',
    'MirrorToolIcon',
    'ModelCombinationShelf',
    'ModelConversionShelf',
    'ModelCreationShelf',
    'NullIcon',
    'RevSurfToolIcon',
    'TextToolIcon',
    'TorusToolIcon',
    'ViewingShelf',
  ],
  'SpecializedTools' : [
    'BevelTool',
    'CSGTool',
    'ClipTool',
    'ClipToolActive',
    'ClipToolClipped',
    'CylinderTool',
    'CylinderToolActive',
    'MirrorTool',
    'MirrorToolTwoAfter',
    'MirrorToolTwoBefore',
    'RevSurfTool',
    'TextTool',
    'TorusTool',
  ],
  'Targets' : [
    'EdgeTarget',
    'EdgeTargetModSnapped',
    'EdgeTargetSnapped',
    'PointTarget',
    'PointTargetModSnapped',
    'PointTargetModSnapped2',
    'PointTargetSnapped',
  ],
  'TargetSnap' : [
    'SnappedToPointTarget',
  ],
  'ToolPanels' : [
    'BevelToolPanel',
    'BevelToolPanelDelete',
    'BevelToolPanelGripMidpoint',
    'BevelToolPanelHover',
    'BevelToolPanelMaxAngle',
    'BevelToolPanelScaleLarge',
    'BevelToolPanelScaleSmall',
    'BevelToolPanelSnap',
    'CSGToolPanel',
    'ImportToolPanel',
    'RevSurfToolPanel',
    'RevSurfToolPanelSweep',
    'TextToolPanel',
  ],
  'TreePanel' : [
    'TreePanel',
    'TreePanelSelect',
    'TreePanelUpDown',
  ],
}

# This maps annotation script files to the images they read and write.
ann_map = {
  'Icons'    : (['WorkArea', 'WorkAreaWithSelection'],
                [
                  'CombineHullIcon',
                  'CreateCylinderIcon',
                  'CreateTorusIcon',
                  'NameToolIcon',
                  'ScaleToolIcon',
                  'SessionPanelIcon',
                ]),
  'WorkArea' : (['WorkArea'], ['WorkAreaAnnotated']),
}

def ImageFile(name):
  return join(image_dir, name + '.jpg')

# Snapshot script processing.
snaps = []
for (script, images) in snap_map.items():
  script_file = script + '.conf'
  snap = env.Command([ImageFile(image) for image in images],
                     [snapimage, join(script_dir, script_file)],
                     f'{snapimage.abspath} --fullscreen {script_file}',
                     chdir=root_dir)
  # This prevents snapimage from running in parallel.
  env.SideEffect('dummy', snap)
  snaps.append(snap)

# Annotation processing.
anns = []
for (script, (input_images, output_images)) in ann_map.items():
  script_file = script + '.conf'
  ann = env.Command([ImageFile(image) for image in output_images],
                    [annotator, join(ann_dir, script_file)] +
                    [ImageFile(image) for image in input_images],
                    f'{annotator} {script_file}',
                    chdir=root_dir)
  anns.append(ann)

env.Alias('Snaps', snaps)
env.Alias('Images', [snaps, anns])

# -----------------------------------------------------------------------------
# Documentation generation.
# -----------------------------------------------------------------------------

# Find the latest tag for each release branch.
# XXXX



sphinx = 'sphinx-build'

sources = FindAllSources_('docs')

sphinx_args = ' '.join([
    '-W',    # Treat warnings as errors,
    '-E',    # Rebuild if anything changes (no environment cache).
    '-a',    # Write all files.
])

# Run Sphinx to build the doc.
doc = env.Command(f'$VERSION_DIR/index.html',
                  sources + [cs_output] + snaps + anns,
                  ['echo === Building public doc for version: $VERSION_SUBDIR',
                   f'{sphinx} {sphinx_args} docs {output_doc_path}'],
                  chdir=f'{root_dir}/PublicDoc')

# Copy the top-level index.html file into the build directory.
index = env.Install(target='$OUTPUT_DIR', source='./index.html')

# Add URL redirect files to "latest" directory. These commands require the rest
# of the doc to be built first.
redirect_files = [
    'index.html',
    'CheatSheet.html',
    'Quickstart.html',
    'ReleaseNotes.html',
    'UserGuide/index.html',
    'VRSetup.html',
]
redirects = []
for rfile in redirect_files:
    from_path = join('latest',      rfile)
    to_path   = join(env.subst('$VERSION_SUBDIR'), rfile)
    abs_from_path = join(env.Dir('$OUTPUT_DIR').abspath, from_path)
    abs_to_path   = join(env.Dir('$OUTPUT_DIR').abspath, to_path)
    redirects.append(env.AddRedirect(target=abs_from_path, source=abs_to_path))

public_doc = [redirects, index]

Return('public_doc')
