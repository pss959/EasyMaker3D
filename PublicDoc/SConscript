# -----------------------------------------------------------------------------
# scons configuration for public documentation using Sphinx.
#
# Generates public documentation using Jekyll in the "PublicDoc/site"
# subdirectory of the build directory.
# -----------------------------------------------------------------------------

from os      import environ, walk
from os.path import basename, join, splitext

Import('snapimage', 'doc_build_dir',
       'APP_NAME', 'SESSION_SUFFIX', 'VERSION_STRING')

# Recursive function to find all files under a root directory.
def FindAllSources(root_dir):
    sources = []
    for root, dirnames, filenames in walk(root_dir, topdown=True):
        # Skip directories beginning with '.'.
        [dirnames.remove(d) for d in list(dirnames) if d.startswith('.')]
        sources += [join(root, fn) for fn in filenames]
    return sources

# -----------------------------------------------------------------------------
# Environment.
# -----------------------------------------------------------------------------

env = Environment(
    OUTPUT_DIR = f'#{doc_build_dir}/PublicDoc',

    # Copy the environment variables for the snapimage application.
    ENV = environ.copy(),
)

# Pass values through to sphinx-build via environment variables.
env.Append(
    ENV = {
        'PROJECT' : APP_NAME,
        'VERSION' : VERSION_STRING,
        'SUFFIX'  : SESSION_SUFFIX,
    },
)

# -----------------------------------------------------------------------------
# Cheat Sheet generation.
# -----------------------------------------------------------------------------

cs_output    = './docs/CheatSheet.rst'
cs_generator = '#build/opt/Apps/createcheatsheet'
env.Command(cs_output, cs_generator, '$SOURCE > $TARGET')

# -----------------------------------------------------------------------------
# Snapshot Image generation and annotation.
# -----------------------------------------------------------------------------

root_dir   = env.Dir('#').abspath   # Work around SCons issue.
image_dir  = './docs/images'
script_dir = './snaps/scripts'
ann_dir    = './snaps/annotations'
annotator  = env.File('#/bin/annotate.py').abspath

# This maps snapimage script files to the images they generate.
snap_map = {
  'CSG'            : [ 'CSGOperands', 'CSGUnion',
                       'CSGIntersection', 'CSGDifference' ],
  'Controller'     : [ 'Vive', 'OculusTouch', 'TouchMode' ],
  'Doorstop'       : [ 'Doorstop' ],
  'Feedback'       : [ 'LinearFeedback', 'AngularFeedback' ],
  'Hull'           : [ 'HullSpheres', 'HullCapsule', 'HullTorus', 'HullDisk' ],
  'InvalidColors'  : [ 'InvalidColors' ],
  'Main'           : [ 'WorkArea', 'PrecisionControl', 'BuildVolume', 'Logo' ],
  'ModelEdges'     : [ 'ModelNoEdges', 'ModelEdges' ],
  'Primitives'     : [ 'PrimitiveBox', 'PrimitiveCylinder', 'PrimitiveSphere',
                       'PrimitiveTorus', 'PrimitiveRevSurf', 'PrimitiveText',
                       'PrimitiveImported' ],
  'Quickstart'     : [ 'SessionPanel', 'QuickstartTorus', 'QuickstartScale',
                       'QuickstartCylinder', 'QuickstartSelected',
                       'QuickstartHull', 'QuickstartRenamed',
                       'QuickstartExport' ],
  'RadialMenu'     : [ 'FixedRadialMenu', 'AttachedRadialMenu' ],
  'Selection'      : [ 'Selection' ],
}

# This maps annotation script files to the images they read and write.
ann_map = {
  'Icons'    : (['WorkArea'],
                [
                  'CombineHullIcon',
                  'CreateCylinderIcon',
                  'CreateTorusIcon',
                  'NameToolIcon',
                  'ScaleToolIcon',
                  'SessionPanelIcon',
                 ]),
  'WorkArea' : (['WorkArea'], ['WorkAreaAnnotated']),
}

def ImageFile(name):
  return join(image_dir, name + '.jpg')

# Snapshot script processing.
snaps = []
for (script, images) in snap_map.items():
  script_file = script + '.conf'
  snap = env.Command([ImageFile(image) for image in images],
                     [snapimage, join(script_dir, script_file)],
                     f'{snapimage.abspath} --fullscreen {script_file}',
                     chdir=root_dir)
  # This prevents snapimage from running in parallel.
  env.SideEffect('dummy', snap)
  snaps.append(snap)

# Annotation processing.
anns = []
for (script, (input_images, output_images)) in ann_map.items():
  script_file = script + '.conf'
  ann = env.Command([ImageFile(image) for image in output_images],
                    [annotator, join(ann_dir, script_file)] +
                    [ImageFile(image) for image in input_images],
                    f'{annotator} {script_file}',
                    chdir=root_dir)
  anns.append(ann)

env.Alias('Snaps', snaps)
env.Alias('Images', [snaps, anns])

# -----------------------------------------------------------------------------
# Documentation generation.
# -----------------------------------------------------------------------------

sources = FindAllSources('docs')
output_dir = env.Dir('$OUTPUT_DIR').abspath

sphinx_args = ' '.join([
    '-W',    # Treat warnings as errors,
    '-E',    # Rebuild if anything changes (no environment cache).
    '-a',    # Write all files.
])

doc = env.Command('$OUTPUT_DIR/index.html',
                  sources + [cs_output] + snaps + anns,
                  ['echo = Building public doc for version: $VERSION_STRING',
                   f'sphinx-build {sphinx_args} docs {output_dir}'],
                  chdir=f'{root_dir}/PublicDoc')
Return('doc')
